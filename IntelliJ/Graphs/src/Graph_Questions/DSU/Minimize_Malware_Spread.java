package Graph_Questions.DSU;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Map;

public class Minimize_Malware_Spread {
    public static void main(String[] args) {
        int[][] graph = {{1,1,1},{1,1,1},{1,1,1}};
        int[] initial = {1,2};

        System.out.println(minMalwareSpread(graph, initial));


    }

    public static int minMalwareSpread(int[][] graph, int[] initial) {
        //doesn't work
        int[] parent = new int[graph.length];
        int[] rank = new int[graph.length];

        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
        }

        Arrays.fill(rank, 1);

        //we don't need to traverse on the complete graph
        //as in the adj matrix representation
        //we've symmetric edges marked as true as 1,2 and 2,1
        //will be both marked a true
        //and if 1, 2 belongs to a set, then obviously 2,1 will
        //also belong to the same set
        //so we'll just traverse on the upper triangle of the matrix
        //or can just do on the lower triangle

        for (int i = 0; i < graph.length; i++) {
            for (int j = i + 1; j < graph.length; j++) {
                if(graph[i][j] == 1) {
                    union(i, j , parent, rank);
                }
            }
        }

        int[] size = new int[graph.length];

        for (int i = 0; i < size.length; i++) {
            //go to every node and find the leader
            //and increase the count of it
            int leader = find(i, parent);
            size[leader]++;
        }

        int[] infectedCount = new int[graph.length];

        for (int i = 0; i < initial.length; i++) {
            int leader = find(initial[i], parent);
            infectedCount[leader]++;
        }

        int ansIndex = -1;
        int ansCount = Integer.MIN_VALUE;

        Arrays.sort(initial);

        //now we just traverse and check
        /*
        for (int i = 0; i < initial.length; i++) {
            int infectedNode = initial[i];
            int leaderOfInfectedNode = find(infectedNode, parent);
            if(infectedCount[leaderOfInfectedNode] > 1) {
                //then saving this is useless
                continue;
            } else if(infectedCount[leaderOfInfectedNode] == 1) {
                //calculate the size of infectedNodes we're saving
                int sizeTemp = size[leaderOfInfectedNode];
                if(sizeTemp > ansCount) {
                    ansIndex = i;
                    ansCount = sizeTemp;
                } else if(sizeTemp == ansCount) {
                    //then check for the index
                    ansIndex = Math.min(i, ansIndex);
                }
            }
        }

         */

        for (int i = 0; i < initial.length; i++) {
            int infectedNode = initial[i];
            int leaderOfInfectedNode = find(infectedNode, parent);
            if(infectedCount[leaderOfInfectedNode] == 1 && size[leaderOfInfectedNode] > ansCount) {
                ansIndex = infectedNode;
                ansCount = size[infectedNode];
            }
        }

        //return initial[ansIndex];
        return ansIndex;
    }

    private static int[][] constructGraph(int[][] graph) {
        //as this is adj mat representation, so this matrix
        //would be of V X V size

        int[][] edges = new int[graph.length][2];
        int index = 0;

        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph[i].length; j++) {
                if(graph[i][j] == 1) {
                    //means they are connected
                    edges[index] = new int[] {i, j};
                    index++;
                }
            }
        }

        return edges;
    }

    public static boolean union(int x, int y, int[] parent, int[] rank) {
        int parentX = find(x, parent);
        int parentY = find(y, parent);

        if(parentX == parentY) {
            return false;
        }

        if(rank[parentX] > rank[parentY]) {
            //merge to the bigger leader
            parent[parentY] = parentX;
        } else if(rank[parentY] > rank[parentX]) {
            parent[parentX] = parentY;
        } else {
            parent[parentX] = parentY;
            rank[parentY]++;
        }

        return true;
    }

    public static int find(int ele, int[] parent) {
        if(ele == parent[ele]) {
            return ele;
        }

        int temp = find(parent[ele], parent);
        parent[ele] = temp;
        return temp;
    }
}
